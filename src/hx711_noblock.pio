; MIT License
; 
; Copyright (c) 2022 Daniel Robertson
; 
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
; copies of the Software, and to permit persons to whom the Software is
; furnished to do so, subject to the following conditions:
; 
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
; 
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
; SOFTWARE.
; 
; This program waits for an integer representing the number of bits
; from application code. That integer is in the range 25 to 27. The
; program sends back a 32-bit integer. The lower 24 bits contain the
; value read from the HX711. The next 1 to 3 bits are incidental to
; setting the HX711's gain and should be ignored by the application.
; 
; Details are given on page 5 of the HX711's datasheet
; 
; NOTES:
; 1. This program assumes the state machine is running at 1MHz.
; 
; 2. When running in serial, there is an overlap between T2 and T3-T4.
; That is to say, the data pin can be read from 0.1us after the clock
; pin has gone high. Given each bit is read in serial, the T2 delay is
; not needed.
; 
.program hx711

.define T1 1                ; 1us
.define T2 1                ; 1us
.define T3 1                ; 1us
.define T4 1                ; 1us

; y is used to store the last bit read count
; x is used to as the bit decrement count for the current loop

set y, 25                   ; used to store the last bit count
                            ; a default 25 is given, as this matches the
                            ; default gain (128) for the HX711

.wrap_target
public start:               ; set to public, because the application
                            ; ought to be able to jump directly to this
                            ; point at any time
    pull                    ; pull in any data if it's available, but don't
                            ; wait if there isn't any
    jmp !osre getbitcount   ; import the bit count if data is available
    mov y, x                ; if the jump didn't occur, copy y into x
                            ; before waiting for the pin

waitpin:
    wait 0 pin 0 [T1 - 1]   ; wait until data pin goes low and delay for
                            ; T1 - 1 cycles
bitloop:
    jmp x-- readbit         ; keep jumping to readbit while x > 0
    push                    ; after reading all bits, push data back to
                            ; application
.wrap

readbit:
    set pins, 1 [T3 - 1]    ; set clock pin high and delay for T3 - 1 cycles
    set pins, 0 [T4 - 1]    ; set clock pin low and delay for T4 - 1 cycles
    in pins, 1              ; read bit from data pin into input register
    jmp bitloop

getbitcount:
    out x, 32               ; copy all the bits from the out register into
                            ; x. even though only 5 bits are needed, copying
                            ; all 32 will clear the out register bit count
                            ; which is needed for the jump !osre condition
    mov x, y                ; store a copy of the bit count
    jmp waitpin             ; go to waiting for the pin to go low


% c-sdk {
// MIT License
// 
// Copyright (c) 2022 Daniel Robertson
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include "hardware/clocks.h"
#include "hardware/pio.h"
#include "../include/hx711.h"

void hx711_program_init(hx711_t* const hx) {

    pio_sm_config cfg = hx711_program_get_default_config(hx->_offset);

    //set state machine to 1MHz clock speed
    const float div = (float)(clock_get_hz(clk_sys)) / 1000000;
    sm_config_set_clkdiv(
        &cfg,
        div);

    //clock pin setup
    pio_sm_set_out_pins(
        hx->_pio,
        hx->_state_mach,
        hx->clock_pin,
        1);

    pio_sm_set_set_pins(
        hx->_pio,
        hx->_state_mach,
        hx->clock_pin,
        1);

    pio_gpio_init(
        hx->_pio,
        hx->clock_pin);

    pio_sm_set_consecutive_pindirs(
        hx->_pio,
        hx->_state_mach,
        hx->clock_pin,
        1,
        true);

    sm_config_set_set_pins(
        &cfg,
        hx->clock_pin,
        1);

    sm_config_set_out_pins(
        &cfg,
        hx->clock_pin,
        1);


    //data pin setup
    pio_sm_set_in_pins(
        hx->_pio,
        hx->_state_mach,
        hx->data_pin);

    pio_sm_set_consecutive_pindirs(
        hx->_pio,
        hx->_state_mach,
        hx->data_pin,
        1,
        false);
    
    pio_gpio_init(
        hx->_pio,
        hx->data_pin);

    sm_config_set_in_pins(
        &cfg,
        hx->data_pin);

    sm_config_set_in_shift(
        &cfg,
        false,
        false,
        32);

    pio_sm_init(
        hx->_pio,
        hx->_state_mach,
        hx->_offset,
        &cfg);

    pio_sm_set_enabled(
        hx->_pio,
        hx->_state_mach,
        true);

}

%}
