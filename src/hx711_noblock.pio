; MIT License
; 
; Copyright (c) 2022 Daniel Robertson
; 
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
; copies of the Software, and to permit persons to whom the Software is
; furnished to do so, subject to the following conditions:
; 
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
; 
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
; SOFTWARE.

; This program pulls a 32-bit integer from application code and uses
; it to set the gain on the HX711. If an integer is not provided, the
; previously provided integer is used. A default integer of 0
; corresponding to a gain of 128 is used until an integer is provided.
; The integer provided should be in the range 0 to 2, inclusive.
; 
; This program constantly and automatically refills the ISR with the
; newest value from the HX711 without providing a gain value from
; application code.
; 
; The lower 24 bits contain the value from the HX711. The next (upper)
; bits should all be 0, but in any case should be ignored by
; application code.
; 
; Details are given on page 5 of the HX711's datasheet.
; 
; NOTES:
; 1. This program assumes the state machine is running at 1MHz.
; 
; 2. When running in serial, there is an overlap between T2 and T3-T4.
; That is to say, the data pin can be read from 0.1us after the clock
; pin has gone high. Given each bit is read in serial, the T2 delay is
; not needed.
; 
; 3. The 'x' register is used to store the last count of bits to read
; and to preload the OSR with if the OSR is empty. See pg. 350 of the
; RP2040 datasheet for details about this when the 'noblock' option is
; given.
;
; 4. The 'y' register is used to as the decrement counter for the bit
; read counter. This variable is 0-based.
; 
.program hx711_noblock

.define READ_BITS 23        ; 24 bits to read from HX711 (this is 0-based)
.define DEFAULT_GAIN 0      ; Default gain (0=128, 1=32, 2=64)
.define T1 1                ; 1us
; .define T2 1              ; 1us - this value is not used (see above)
.define T3 1                ; 1us
; .define T4 1              ; 1us - this value is not used (see below)

set x, DEFAULT_GAIN         ; Set an initial default gain (this is 0-based).

.wrap_target

set y, READ_BITS            ; Read y number of bits. This is 0-based.

wait 0 pin 0 [T1 - 1]       ; Wait until data pin goes low and delay for
                            ; T1 - 1 cycles. The delay between going low and
                            ; the first rising clock pulse is min 0.1us. So
                            ; a 1us delay is more than sufficient.

bitloop:
    set pins, 1 [T3 - 1]    ; Set clock pin high and delay.
    set pins, 0 ; [T4 - 1]  ; Set clock pin low and delay. There is only a
                            ; 0.1us delay between the clock pin going high
                            ; and the data pin being ready. Given the above
                            ; T3 delay, a second delay should not be needed.

    in pins, 1              ; Read bit from data pin into ISR.

    jmp y-- bitloop         ; Keep jumping back to bitloop while y > 0.

                            ; At this point, all 24 bits have been read
                            ; and can be pushed back to the application. A
                            ; manual 'push noblock' is not used in favour of
                            ; autopush, which is configured in the init
                            ; function below.

                            ; Defer obtaining the gain from the application
                            ; until the last moment. So...

    pull noblock            ; Pull in any data if it's available, but don't
                            ; wait if there isn't any. If no data is there,
                            ; preload from x (this is what noblock does).

    out x, 2                ; Get 2 bits from the OSR into x. This is enough
                            ; to hold the max expected value (2). x will also
                            ; persist after the wrap loop.

    mov y, x                ; Copy x into y. y will hold the number of clock
                            ; pulses minus 1 to be used as the following loop
                            ; counter.

gainloop:
    set pins, 1 [T3 - 1]    ; Set clock pin high and delay.
    set pins, 0             ; Set clock pin low.

                            ; No need to read from the data pin, so also no
                            ; need to delay.

    jmp y-- gainloop        ; Keep pulsing clock pin while y > 0.

                            ; At this point, the gain has been set for the
                            ; next reading, so go back to the start.

.wrap


% c-sdk {
// MIT License
// 
// Copyright (c) 2022 Daniel Robertson
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include <assert.h>
#include <stdbool.h>
#include <stddef.h>
#include "hardware/clocks.h"
#include "hardware/pio.h"
#include "../include/hx711.h"

void hx711_noblock_program_init(hx711_t* const hx) {

    assert(hx != NULL);
    assert(hx->_pio != NULL);

    pio_sm_config cfg = hx711_noblock_program_get_default_config(hx->_offset);

    //set state machine to 1MHz clock speed
    const float div = (float)(clock_get_hz(clk_sys)) / 1000000;

    sm_config_set_clkdiv(
        &cfg,
        div);

    //clock pin setup
    pio_sm_set_out_pins(
        hx->_pio,
        hx->_state_mach,
        hx->clock_pin,
        1);

    pio_sm_set_set_pins(
        hx->_pio,
        hx->_state_mach,
        hx->clock_pin,
        1);

    pio_gpio_init(
        hx->_pio,
        hx->clock_pin);

    pio_sm_set_consecutive_pindirs(
        hx->_pio,
        hx->_state_mach,
        hx->clock_pin,
        1,
        true);

    sm_config_set_set_pins(
        &cfg,
        hx->clock_pin,
        1);

    sm_config_set_out_pins(
        &cfg,
        hx->clock_pin,
        1);


    //data pin setup
    pio_sm_set_in_pins(
        hx->_pio,
        hx->_state_mach,
        hx->data_pin);

    pio_sm_set_consecutive_pindirs(
        hx->_pio,
        hx->_state_mach,
        hx->data_pin,
        1,
        false);
    
    pio_gpio_init(
        hx->_pio,
        hx->data_pin);

    sm_config_set_in_pins(
        &cfg,
        hx->data_pin);

    /**
     * Why enable autopush?
     *
     * "The state machine keeps an eye on the total amount of data shifted into the ISR, and on the in which reaches or
     *  breaches a total shift count of 32 (or whatever number you have configured), the ISR contents, along with the new data
     *  from the in. goes straight to the RX FIFO. The ISR is cleared to zero in the same operation."
     *  - Raspberry Pi Pico C/C++ SDK pg. 45
     *
     * When manually pushing using noblock, the FIFO contents are NOT changed.
     * 
     * "The PIO assembler sets the Block bit by default. If the Block bit is not set, the PUSH does not stall on a full RX FIFO, instead
     * continuing immediately to the next instruction. The FIFO state and contents are unchanged when this happens. The ISR
     * is still cleared to all-zeroes, and the FDEBUG_RXSTALL flag is set (the same as a blocking PUSH or autopush to a full RX FIFO)
     * to indicate data was lost."
     * - Raspberry Pi Pico C/C++ SDK pg. 64
     * 
     * Manually pushing is not ideal. Application code should be able to look at the FIFO and assume
     * that the value inside is the most up-to-date data available. Autopushing does this.
     */
    sm_config_set_in_shift(
        &cfg,
        false, //false=shift in left
        true, //true=autopush enabled
        HX711_READ_BITS); //autopush on 24 bits

    //store a copy of the configuration for resetting the sm
    hx->_default_config = cfg;

    pio_sm_init(
        hx->_pio,
        hx->_state_mach,
        hx->_offset,
        &cfg);

}

%}
